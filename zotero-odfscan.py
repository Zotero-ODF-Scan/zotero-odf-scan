#!/usr/bin/python
'''
Convert MLZ drag-and-drop link cites in an ODF document to MLZ linked references

Processing sequence:

        self.copyZipFile(ifilename, ofilename)
        self.openZipFile(ofilename)
        self.readContent()
        self.normalizeLinkedMarks()
        self.normalizeNativeMarks()
        self.composeCitations()
        self.writeContent()
        self.purgeConfig()
        self.closeZipFile()
'''

import sys,os,re
import zipfile
import json
import random
import shutil
from tempfile import mkdtemp

#
# Start % (items, rand1, items, rand1)
tmplCitation = "<text:reference-mark-start text:name=\"ZOTERO_ITEM {&quot;properties&quot;:{&quot;formattedCitation&quot;:&quot;%s&quot;},&quot;citationItems&quot;:%s} RND%s\"/>%s<text:reference-mark-end text:name=\"ZOTERO_ITEM {&quot;properties&quot;:{&quot;formattedCitation&quot;:&quot;%s&quot;},&quot;citationItems&quot;:%s} RND%s\"/>"
#
# Item % ("key",key) OR tmplItem % ("id", id)
## GENERATED by building a list of maps and dumping as JSON

#
# tmplText % (prefix, pinpoint, suffix, id)
tmplText = "{ %s | %s | %s | %s |zotero://select/items/%s}"


rexPref = '<meta:user-defined meta:name="ZOTERO_PREF[^<]*?</meta:user-defined>'

labels = {"article": "art",
          "chapter": "ch",
          "Chapter": "Ch",
          "subchapter": "subch",
          "column": "col",
          "figure": "fig",
          "line": "l",
          "note": "n",
          "issue": "no",
          "opus": "op",
          "page": "p",
          "page": "pp",
          "paragraph": "para",
          "subparagraph": "subpara",
          "part": "pt",
          "rule": "r",
          "section": "sec",
          "subsection": "subsec",
          "Section": "Sec",
          "sub-verbo": "sv",
          "schedule": "sch",
          "title": "tit",
          "verse": "vrs",
          "volume": "vol"}

rexLabels = "^((?:art|ch|Ch|subch|col|fig|l|n|no|op|p|pp|para|subpara|pt|r|sec|subsec|Sec|sv|sch|tit|vrs|vol)\\.)\\s+(.*)"

class MismatchedTagException(Exception):
    pass

class Fragment:
    def __init__(self, txt):
        self.txt = txt
        self.newtxt = txt

    def normalizeStringMarks(self):
        # Normalize intended rexText entries
        #  replace XML space with space
        rexSpace = re.compile("<text:s/>")
        self.newtxt = re.sub(rexSpace, " ", self.newtxt)
        #  replace other singletons with empty string
        rexSingleton = re.compile("<[^>]*/>")
        self.newtxt = re.sub(rexSingleton, "", self.newtxt)        
        #  remove balanced braces
        while 1:
            rexBalancedTags = re.compile("(.*)<([^/>][-:a-zA-Z0-9]*)[^>]*>([^>]*)</([-:a-zA-Z0-9]*)[^>]*>(.*)")
            m = re.match(rexBalancedTags, self.newtxt)
            if m:
                if m.group(2) == m.group(4):
                    self.newtxt = re.sub(rexBalancedTags, "\\1\\3\\5", self.newtxt)
                else:
                    # If tags are mismatched the file is corrupt.
                    # Don't make the situation worse.
                    raise MismatchedTagException
            else:
                break
        #  move open tags to the end
        newlst = []
        lst = re.split("(<[^/>][^>]*>)",self.newtxt)
        for i in range(0,len(lst),2):
            newlst.append(lst[i])
        for i in range(1,len(lst),2):
            newlst.append(lst[i])
        self.newtxt = "".join(newlst)
        # move close tags to the front
        newlst = []
        lst = re.split("(</[^>]*>)",self.newtxt)
        for i in range(1,len(lst),2):
            newlst.append(lst[i])
        for i in range(0,len(lst),2):
            newlst.append(lst[i])
        self.newtxt = "".join(newlst)

    def normalizeLinkedMarks(self):
        rexLink = re.compile("<[^>]*xlink:href=\"([^\"]*)\"[^>]*>\s*{([^|}]*)\|([^|}]*)\|([^|}]*)\|([^|}]*)}\s*<[^>]*>")
        self.newtxt = re.sub(rexLink, "{\\2|\\3|\\4|\\5|\\1}", self.newtxt)

    def normalizeNativeMarks(self):
        # Normalize all rexNative entries to rexText
        rexNativeLink = re.compile("<text:reference-mark-start[^>]*ZOTERO_ITEM\s+(?:CSL_CITATION\s+)*([^>]*)\s+[^ ]*/>([^<]*)<text:reference-mark-end[^>]*/>")
        m = re.match(rexNativeLink,self.newtxt)
        if m:
            m_citation = m.group(1)
            m_plaintext = m.group(2)
            replacement = ""
            obj_txt = m_citation.replace("&quot;",'"')
            obj = json.loads(obj_txt)
            count = 1
            for item in obj["citationItems"]:
                for key in ["prefix", "locator", "suffix"]:
                    if not item.has_key(key):
                        item[key] = ""
                if item.has_key("label") and item["locator"]:
                    m = re.match(rexLabels, item["locator"])
                    if not m:
                        item["locator"] = "%s. %s" % (labels[item["label"]], item["locator"])
                # Needs remapping of locator label. Tricky.
                replacement += tmplText % (item["prefix"], m_plaintext, item["locator"], item["suffix"], item["key"])
                count += 1
            self.newtxt = replacement

    def finalize(self):
        m = re.match("(<[^/>][^>]*>)*{[^<>\|]*|[^<>\|]*|[^<>\|]*|[^<>\|]*|[^<>\|]*}(</[^>]*>)*", self.newtxt)
        if m:
            self.txt = self.newtxt

class ODFConv:
    def __init__(self, ifilename, ofilename, reverse_conversion=False):
        self.rands = {}
        self.readZipfileContent(ifilename)

        # Matches plain text links
        rexZotLinks1 = re.compile("({[^\|]*\|[^\|]*\|[^\|]*\|[^\|]*\|[^\|]*})")
        lst = re.split(rexZotLinks1,self.content)
        for i in range(0,len(lst),1):
            lst[i] = Fragment(lst[i])
        for i in range(len(lst)-2,-1,-2):
            lst[i].normalizeStringMarks()
            lst[i].finalize()
        self.rejoin(lst)

        # Matches wrapped text links
        rexZotLinks2 = re.compile("(<[^>]*xlink:href=\"[^\"]*\"[^>]*>\s*{[^|}]*\|[^|}]*\|[^|}]*\|[^|}]*}\s*<[^>]*>)")
        lst = re.split(rexZotLinks2,self.content)
        for i in range(0,len(lst),1):
            lst[i] = Fragment(lst[i])
        for i in range(len(lst)-2,-1,-2):
            lst[i].normalizeLinkedMarks()
            lst[i].finalize()
        self.rejoin(lst)

        # Matches native links
        rexNativeLinks = re.compile("(<text:reference-mark-start[^>]*ZOTERO_ITEM\s+(?:CSL_CITATION\s+)*[^>]*/>[^<]*<text:reference-mark-end[^>]*/>)")
        lst = re.split(rexNativeLinks,self.content)
        for i in range(0,len(lst),1):
            lst[i] = Fragment(lst[i])
        for i in range(len(lst)-2,-1,-2):
            lst[i].normalizeNativeMarks()
            lst[i].finalize()
        self.rejoin(lst)

        self.tidy()

        # Maybe convert to live cites
        if not reverse_conversion:
            self.composeCitations()

        self.purgeConfig()
        self.writeZipfileContent(ofilename)

    def rejoin(self, lst):
        self.content = "".join([frag.txt for frag in lst])

    def tidy(self):
        # Eliminate empty balance spans between cites
        rexCite = "({[^<>\|]*\|[^<>\|]*\|[^<>\|]*\|[^<>\|]*\|[^<>\|]*})"
        lst = re.split(rexCite,self.content)
        for i in range(0,len(lst),2):
            if re.match("^<text:span[^>]*></text:span[^>]*>$",lst[i]):
                lst[i] = ""
        self.content = "".join(lst)
    
    def composeCitations(self):
        # Split file string to twin lists
        # and reverse iterate over cites (master recomposition loop)
        # compose item
        # compose citation
        rexText = "{\s*([^|}]*)\|\s*([^|}]*)\s*\|\s*([^|}]*)\s*\|([^|}]*?)\s*\|\s*([^|}]*)\s*}"
        rexTextPlain = "{[^|}]*\|[^|}]*\|[^|}]*\|[^|}]*\|[^|}]*}"
        ret = []
        items = []
        m = re.findall(rexText,self.content)
        #for item in m:
        #    print item
        lst = re.split(rexTextPlain,self.content)
        ret.append(lst[-1])
        placeholder = []
        for i in range(len(m) - 1, -1, -1):
            placeholder.append(m[i][1].strip())
            item = {}
            item['prefix'] = self.fixMarkup(m[i][0]).lstrip()
            item['locator'] = self.fixMarkup(m[i][2]).strip()
            item['suffix'] = self.fixMarkup(m[i][3]).rstrip()
            link = self.fixMarkup(m[i][4]).strip()
            for key in ['prefix', 'suffix', 'locator']:
                if not item[key].strip():
                    item.pop(key)
                else:
                    item[key] = item[key].replace('&quot;','"')
            myid = link[22:]
            myidlst = myid.split('_')
	    if len(myidlst) == 1:
           	item['id'] = myid
            else:
	    	print myidlst[1]
	    	item['key'] = myidlst[1]
            items = [item] + items
            if lst[i]:
                placeholder = "; ".join(placeholder)
                items = json.dumps(items)
                items = items.replace('"', '&quot;')
                randstr = self.generateRandomString()
                citation = tmplCitation % (placeholder, items, randstr, placeholder, placeholder, items, randstr)
                ret.append(citation)
                ret.append(lst[i])
                items = []
                placeholder = []
        ret.reverse()
        self.content = "".join(ret)

    def fixMarkup(self, str):
        str = re.sub("\*\*(.*?)\*\*", "&lt;b&gt;\\1&lt;/b&gt;", str)
        str = re.sub("\*(.*?)\*", "&lt;i&gt;\\1&lt;/i&gt;", str)
        return str

    def generateRandomString(self):
        # Generate unique random string
        # chrs: 49-57, 65-90, 97-122
        while 1:
            num = range(49, 58, 1)
            cap = range(65, 91, 1)
            lower = range(97, 123, 1)
            nums = num + cap + lower
            randstr = ""
            for digit in range(0, 10, 1):
                randstr += chr(nums[random.randrange(0, 61, 1)])
            if not self.rands.has_key(randstr):
                self.rands[randstr] = True
                break
        return randstr

    def readZipfileContent(self, ifilename):
        # make temporary directory
        self.tmpdir = mkdtemp()
        # get meta and content, and set up working area
        z = zipfile.ZipFile(ifilename, "r")
        self.content = z.open("content.xml").read()
        self.meta = z.open("meta.xml").read()
        z.extractall(path=self.tmpdir)
        z.close()

    def purgeConfig(self):
        # Scrub configuration from meta.xml
        self.meta = re.sub(rexPref, "", self.meta)

    def writeZipfileContent(self, ofilename):
        # move to working area
        origdir = os.getcwd()
        os.chdir(self.tmpdir)
        # write our finished content to file
        open("content.xml","w+").write(self.content)
        open("meta.xml","w+").write(self.meta)
        # write files into the zipfile
        z = zipfile.ZipFile(ofilename, "w")
        if self.tmpdir and self.tmpdir != origdir:
            for root, dirs, files in os.walk(".",topdown=False):
                for f in files:
                    if f == ofilename:
                        continue
                    filepath = os.path.join(root,f)
                    z.write(filepath)
        z.testzip()
        z.close()
        # return to working area and write out the finished zipfile
        filecontent = open(ofilename).read()
        os.chdir(origdir)
        open(ofilename,"w+").write(filecontent)
        # remove working area
        # DON'T CHANGE self.tmpdir TO ANOTHER VALUE!
        if self.tmpdir and self.tmpdir != origdir:
            for root, dirs, files in os.walk(self.tmpdir,topdown=False):
                for f in files:
                    filepath = os.path.join(root,f)
                    os.unlink(filepath)
                os.rmdir(root)

if __name__ == "__main__":

    from optparse import OptionParser
    os.environ['LANG'] = "en_US.UTF-8"
    usage = 'zodfscan <input_file> <output_file>'
    description='''Converts MLZ linked QuickCopy cites in an ODF document to live Zotero citations.
Adjacent cites of any type (QuickCopy or Zotero plugin cites) are merged to form multiple citations.'''
    parser = OptionParser(usage=usage,description=description,epilog="Enjoy!")
    parser.add_option("-F", "--force", dest="force_overwrite",
                      default=False,
                      action="store_true", 
                      help='Overwrite an existing output file.')
    parser.add_option("-R", "--reverse", dest="reverse_conversion",
                      default=False,
                      action="store_true", 
                      help='Convert live Zotero citations to wrapped cite strings.')
    (opt, args) = parser.parse_args()

    error = ""
    if not len(args) == 2:
        parser.print_help()
        print "\nERROR: zodfscan requires exactly two arguments. See above."
        sys.exit()

    if not os.path.exists(args[0]):
        error = "\nERROR: input file does not exist."

    if os.path.exists(args[1]) and not opt.force_overwrite:
        error += "\nERROR: output file already exists.\n       Choose another filename or use the -F option."
    
    if args[0] == args[1] and opt.force_overwrite:
        error += "\nERROR: overwriting the input file is not permitted."

    if error:
        parser.print_help()
        print error
        sys.exit()

    odf = ODFConv(args[0], args[1], opt.reverse_conversion)
    print "Successfully converted: %s" % (args[1],)
    print ""
    print '''Open the file with Zotero enabled and select an in-text style
(author-date or numeric) to initialise the citations.'''
